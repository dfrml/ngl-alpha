<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta charset="utf-8">
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet"></script>
  <script src="utils.js"></script>
  <script src="opencv3_4.js" type="text/javascript"></script>
  <script src="https://kit.fontawesome.com/b7835224ad.js" crossorigin="anonymous"></script>
  <title></title>
  <style>
    body,html {
      padding: 0;
      margin: 0;
      font-family: Montserrat, Verdana;
      color: white;
      background-color: black;
      overflow: hidden;
    }

    video {
      position: fixed;
      top: 50%;
      left: 50%;
      z-index: 1;
      min-width: 100%;
      min-height: 100%;
      width: auto;
      height: auto;
      transform: translate(-50%, -50%);
    }
    .inputCanvasVisible {
      position: fixed;
      z-index: 1;
      /* border-radius: 100px; */
      height: 100%;
      width: 100%;}
    .inputCanvasHidden {display: none;}
    .top {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      padding: 25px;
      z-index: 2;
      /* display: flex; */
      /* justify-content: left; */
      /* background-color: red; */
    }

    .top p,
    .bottom p {
      opacity: 0.7;
      font-size: 0.9em;
    }

    .bottom {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 25px;
      z-index: 2;
      /* display: flex;
      justify-content: center; */
      /* background-color: red; */
    }

    button {
      background-color: white;
      /* opacity: 0.7; */
      /* color: white; */
      /* width: 100%; */
      border-radius: 30px;
      border: none;
      padding: 20px 30px;
      /* margin-bottom: 30px; */
      font-size: 1em;
      font-weight: bold;
      cursor: pointer;
    }

    button:active,
    button:focus {
      background-color: white;
      color: black;
    }

    .imagePreview {
      z-index: 10;
      /* border-radius: 100px; */
      height: 100px;
      margin-right: 10px;
    }

    .fakeInput {
      position: relative;
      overflow: hidden;
      display: inline-block;
    }
    .fakeInput input[type=file] {
      font-size: 100px;
      position: absolute;
      left: 0;
      top: 0;
      opacity: 0;
      cursor: pointer;
    }
    .none {display: none;}
    .loading {display: inline; background-color: yellow;}
  </style>
</head>

<body>
  <!-- thanks https://davidwalsh.name/browser-camera -->
  <!-- <canvas id="imageInputCanvas" style="display: hidden; z-index: 10;"></canvas> -->
  <video id="video" autoplay playsinline muted></video>
  <canvas id="imageInputCanvas" class="inputCanvasHidden"></canvas>
  <div class="top">
    <h1>NGL-measure</h1>
    <p>alpha 0.4 210207</p>
    <div id="result"></div>
    <div id="resultJSON" style="font-size: 0.6em;"></div>
  </div>
  <div class="bottom">
    <!-- <div id="imagePreviews"></div> -->
    <canvas id="imageCropped" class="imagePreview"></canvas>
    <canvas id="imageFaceDetected" class="imagePreview"></canvas>
    <canvas id="imageCaptured" width="640 "height="480" class="none"></canvas>
    <p>Measure SSS using camera. Classify image into three states {high/medium/low}.</p>
    <button id="snap">Snap Photo</button>
    <button id="snapLoading" class="none"><i class="fas fa-atom fa-spin"></i> Computing</button>
    <div id="fakeInput" class="fakeInput"><button>From File</button><input type="file" id="imageInput" accept="image/*"/></div>
    <button id="fakeInputLoading" class="none"><i class="fas fa-atom fa-spin"></i> Computing</button>
  </div>

  <script>
    // ⭐️⭐️⭐️ FROM FILE classification
    // https://educity.app/web-development/how-to-upload-and-draw-an-image-on-html-canvas
    let imgInput = document.getElementById('imageInput');
    var myCanvas = document.getElementById("imageInputCanvas"); // Creates a canvas object
    doClassify = false;
    imgInput.addEventListener('change', function(e) {
      document.getElementById('fakeInput').className = "none";document.getElementById('fakeInputLoading').className = "loading"; // start calc anitmation
      if (e.target.files) {
        let imageFile = e.target.files[0]; //here we get the image file
        var reader = new FileReader();
        reader.readAsDataURL(imageFile);
        reader.onloadend = function(e) {
          var myImage = new Image(); // Creates image object
          myImage.src = e.target.result; // Assigns converted image to image object
          myImage.onload = function(ev) {
            var myContext = myCanvas.getContext("2d"); // Creates a contect object
            myCanvas.width = myImage.width; // Assigns image's width to canvas
            myCanvas.height = myImage.height; // Assigns image's height to canvas
            console.log(myImage.width);
            myContext.drawImage(myImage, 0, 0); // Draws the image on canvas
            myCanvas.className = "inputCanvasVisible";
            cropImage(myCanvas);
            classifyStaticImage();
          }
        }
      }
    });

    // ⭐️⭐️⭐️ SNAP PHOTO classification
    var snapButton = document.getElementById("snap");
    var video = document.getElementById('video');
    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
      navigator.mediaDevices.getUserMedia({
        video: true
      }).then(function(stream) {
        video.srcObject = stream;
        video.play();
      });
    }
    // Elements for taking the snapshot
    var canvas = document.getElementById('imageCaptured');
    var context = canvas.getContext('2d');
    var video = document.getElementById('video');
    // Trigger photo take
    document.getElementById("snap").addEventListener("click", function() {
      reset();
      // myCanvas.className = 'inputCanvasHidden'; // reset canvas if previously used by uploading to input
      document.getElementById('snap').className = "none";document.getElementById('snapLoading').className = "loading"; // start calc anitmation
      context.drawImage(video, 0, 0); //context.drawImage(video, 0, 0, 640, 480);
      cropImage('imageCaptured');
      classifyStaticImage();
    });
  </script>



  <script>
  // ********** CROP INPUT IMAGE using OPENCV
  function cropImage(imgToCrop) {
    const utils = new Utils('errorMessage');
    let faceCascadeFile = 'haarcascade_frontalface_default.xml';
    utils.createFileFromUrl(faceCascadeFile, faceCascadeFile, () => {
      let src = cv.imread(imgToCrop);
      let gray = new cv.Mat();
      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
      let faces = new cv.RectVector();
      let faceCascade = new cv.CascadeClassifier();
      // load pre-trained classifiers
      faceCascade.load(faceCascadeFile);
      // detect faces
      let msize = new cv.Size(0, 0);
      faceCascade.detectMultiScale(gray, faces, 1.1, 3, 0, msize, msize);

      // TODO: check is face detected. If not return error.
      if (faces.size() == 1) {
        console.log('Face detected');
        let roiGray = gray.roi(faces.get(0));
        let roiSrc = src.roi(faces.get(0));
        let point1 = new cv.Point(faces.get(0).x, faces.get(0).y);
        let point2 = new cv.Point(faces.get(0).x + faces.get(0).width, faces.get(0).y + faces.get(0).height);
        console.log('src: ', src);
        console.log('point1: ', point1);
        console.log('point2: ', point2);
        cv.rectangle(src, point1, point2, [255, 0, 0, 255], 2); // cv2.rectangle(image, start_point, end_point, color, thickness)
        // let dsize = new cv.Size(src.rows, src.cols);
        // console.log(dsize);
        roiGray.delete();
        roiSrc.delete();
        let rectX = point1.x + 2;
        let rectY = point1.y + 2;
        let rectSize = (point2.x - point1.x) - 4;

        // TODO: check if the image is at least 224 in size. If not return error.
        let dst = new cv.Mat();
        let rect = new cv.Rect(rectX, rectY, rectSize, rectSize);
        dst = src.roi(rect);
        cv.imshow('imageFaceDetected', src); // image with rectangle
        cv.imshow('imageCropped', dst); // cropped image
        src.delete();
        gray.delete();
        faceCascade.delete();
        cv.FS_unlink(faceCascadeFile);
        doClassify = true;
        console.log('cropping doclassify: ', doClassify);
      } else {
        console.log('No face detected');
        cv.FS_unlink(faceCascadeFile);
        doClassify = false;
      }

    });
    // document.getElementById('imagePreviews').innerText = "Snapped images:";
  }

  // ********** CLASSIFY IMAGE AND PRINT RESULTS
  // @ ANT example https://www.alibabacloud.com/blog/tensorflow-js-helps-recognize-large-quantities-of-icons-in-milliseconds_597000
  async function classifyStaticImage() {
    // ********** LOAD AND INIT
    const imageToClassify = imageCropped;
    const model = await tf.loadGraphModel('210126a_TFjs/model.json');
    const IMAGE_SIZE = 224;
    const LABELS = ['high', 'low', 'medium'];

    // this is used to match the prediction results and labels
    function findIndicesOfMax(inp, count) {
      const outp = [];
      for (let i = 0; i < inp.length; i += 1) {
        outp.push(i); // add index to output array
        if (outp.length > count) {
          outp.sort((a, b) => inp[b] - inp[a]); // descending sort the output array
          outp.pop(); // remove the last index (index of smallest element in output array)
        }
      }
      return outp;
    }

    // ********** MAKE TENSOR FROM IMAGE AND PREPROCESS
    // Convert images into tensors
    const img = tf.browser.fromPixels(imageToClassify).toFloat();
    const offset = tf.scalar(127.5);
    // Normalize an image from [0, 255] to [-1, 1]
    const normalized = img.sub(offset).div(offset);
    // Change the image size
    let resized = normalized;
    if (img.shape[0] !== IMAGE_SIZE || img.shape[1] !== IMAGE_SIZE) {
      const alignCorners = true;
      resized = tf.image.resizeBilinear(
        normalized, [IMAGE_SIZE, IMAGE_SIZE], alignCorners,
      );
    }
    // Change the shape of a tensor to meet the model requirements
    const batched = resized.reshape([-1, IMAGE_SIZE, IMAGE_SIZE, 3]);


    // ********** RUN INFERENCE
    let pred = model.predict(batched).squeeze().arraySync();
    // console.log(pred);
    // Find the categories with the highest matching degree
    const predictions = findIndicesOfMax(pred, 3).map(i => ({
      className: LABELS[i],
      confidence: Math.round(pred[i] * 1000) / 1000,
    }));

    // ********** PRINT THE RESULTS
    console.log('Inference results: ', predictions);
    // find and print object with highest confidence score
    var res = Math.max.apply(Math, predictions.map(function(o) {
      return o.confidence;
    }))
    var obj = predictions.find(function(o) {
      return o.confidence == res;
    })
    console.log('Top prediction: ', obj);
    console.log('Result confidence rounded: ', obj.confidence);
    document.getElementById('result').innerText = `prediction: ${obj.className}\n confidence: ${obj.confidence}`;
    // print detailed results
    document.getElementById('resultJSON').innerText = 'Detailed results:\n' + JSON.stringify(predictions); //JSON.stringify(predictions, null, 4)
    // document.getElementById('result').innerText = `prediction: ${predictions[0].className}\n confidence: ${predictions[0].confidence}`;

    // save image to imgbb. thanks https://stackoverflow.com/a/59551120
    console.log('imageToClassify - width: ', imageToClassify.width);
    console.log('imageToClassify - height: ', imageToClassify.height);
    var base64img = imageToClassify.toDataURL().split(",")[1];

    data = new FormData()
    data.set('key','e5d552739119c31425f04a7885ffe04d')
    data.set('name', obj.className + obj.confidence)
    data.set('image', base64img)

    let request = new XMLHttpRequest();
    request.open("POST", 'https://api.imgbb.com/1/upload', true);
    request.send(data);

    // stop calc anitmation
    document.getElementById('snap').className = ""; document.getElementById('snapLoading').className = "none";
    document.getElementById('fakeInput').className = "fakeInput";document.getElementById('fakeInputLoading').className = "none";
  }

  function reset(){
    myCanvas.className = 'inputCanvasHidden';
  }
  </script>


</body>

</html>
